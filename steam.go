// Package steamutils provides utilities for reading Steam application installation data.
//
// CAUTION: This package was generated by an LLM. It has not been thoroughly tested or verified
// for production use. Use with caution and verify behavior before deploying to production.
//
// The package supports Windows, Linux, and macOS platforms and can:
//
//   - Detect Steam installation paths
//   - Parse Steam library configuration files
//   - Read application manifest files
//   - Extract installed application metadata
//   - Handle custom Steam paths and configurations
//
// Basic usage:
//
//	reader, err := NewSteamReader(SteamReaderConfig{})
//	if err != nil {
//		log.Fatal(err)
//	}
//	apps, err := reader.GetAllInstalledApps()
//
// To specify a custom Steam path:
//
//	config := SteamReaderConfig{
//		CustomSteamPath: "/custom/steam/path",
//	}
//	reader, err := NewSteamReader(config)
//
// On Windows, Steam path is detected from the registry. On Linux and macOS,
// standard installation paths are checked. Custom paths can be provided via
// SteamReaderConfig.
package steamutils

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/iancoleman/orderedmap"
)

// NewSteamReader creates a new SteamReader with the provided configuration.
//
// The function automatically detects the Steam installation path and library configuration
// unless custom paths are provided in SteamReaderConfig.
//
// On Windows, the registry (HKEY_CURRENT_USER\Software\Valve\Steam) is checked.
// On Linux and macOS, standard installation paths are checked in order of likelihood.
//
// Returns an error if Steam cannot be located or if libraryfolders.vdf cannot be read.
//
// WARNING: This function was generated by an LLM. Thoroughly test before production use.
func NewSteamReader(steamReaderConfig SteamReaderConfig) (steamreader SteamReader, err error) {

	if steamReaderConfig.UserName != "" {
		customUser = steamReaderConfig.UserName
	}

	if steamReaderConfig.LibraryVdfPathFinder == nil {
		steamReaderConfig.LibraryVdfPathFinder = checkDefaultLibraryPath
	}

	steamReaderConfig.customSteamPathFinder = true
	if steamReaderConfig.SteamPathFinder == nil {
		steamReaderConfig.SteamPathFinder = GetSteamPath
		steamReaderConfig.customSteamPathFinder = false
	}

	steamreader.SteamReaderConfig = steamReaderConfig

	if steamReaderConfig.CustomSteamPath == "" {
		steamreader.steamPath, err = steamreader.SteamReaderConfig.SteamPathFinder()
		if err != nil {
			return
		}
	}

	if steamReaderConfig.CustomLibraryVdfPath == "" {
		steamreader.libraryVdfPath, err = steamreader.SteamReaderConfig.LibraryVdfPathFinder(steamreader.steamPath)
		if err != nil {
			return
		}
	}

	libraryVdfByte, err := os.ReadFile(steamreader.libraryVdfPath)
	if err != nil {
		return
	}

	steamreader.libraryVdfMap, err = Unmarshal(libraryVdfByte)
	if err != nil {
		return
	}

	return
}

// FindAppIDBuildID returns the build ID for the specified application.
//
// It locates the application in the library configuration and reads the appmanifest file
// to extract the build ID. Returns an error if the application is not found or the
// manifest file cannot be read.
func (steamreader *SteamReader) FindAppIDBuildID(AppID string) (buildId string, err error) {

	dir, err := steamreader.FindAppIDPath(AppID)
	if err != nil {
		return
	}

	f, err := os.ReadFile(dir + pathSeparator() + "steamapps" + pathSeparator() + "appmanifest_" + AppID + ".acf")
	if err != nil {
		return
	}

	acf, err := Unmarshal(f)
	if err != nil {
		return
	}

	if appStateRaw, exists := acf.Get("AppState"); exists {
		if appState, ok := appStateRaw.(*orderedmap.OrderedMap); ok {
			buildIdInt, found := appState.Get("buildid")
			if found {
				buildId = buildIdInt.(string)
			}

		}
	}
	return

}

func checkDefaultLibraryPath(steamPath string) (librarypath string, err error) {
	// Use Stat instead of opening the file to avoid leaking file handles
	_, err = os.Stat(steamPath + pathSeparator() + "steamapps" + pathSeparator() + "libraryfolders.vdf")
	if err != nil {
		return
	}

	librarypath = steamPath + pathSeparator() + "steamapps" + pathSeparator() + "libraryfolders.vdf"
	return
}

// GetLibraryVdfMap returns the parsed library configuration data as an OrderedMap.
//
// The returned map contains the structure of libraryfolders.vdf with library entries
// indexed by key (typically "0", "1", etc.).
func (steamreader *SteamReader) GetLibraryVdfMap() *orderedmap.OrderedMap {
	return steamreader.libraryVdfMap
}

// GetSteamPath returns the Steam installation directory path.
//
// If FormatSteamPath is enabled in SteamReaderConfig, the path is normalized
// with proper case handling and path separators. Returns the raw path otherwise.
func (steamreader *SteamReader) GetSteamPath() string {
	if !steamreader.SteamReaderConfig.customSteamPathFinder {
		pathStrings := strings.Split(steamreader.steamPath, pathSeparator())
		if len(pathStrings) == 0 {
			return steamreader.steamPath
		}
		rebuiltPathString := strings.ToUpper(pathStrings[0]) + "/"

		// Handle "Program Files (x86)" case insensitively
		if len(pathStrings) > 1 && strings.ToLower(pathStrings[1]) == "program files (x86)" {
			rebuiltPathString += "Program Files (x86)" + pathSeparator()

			for x, y := range pathStrings {
				if x == 0 || x == 1 {
					continue
				}
				if strings.ToLower(y) == "steam" {
					rebuiltPathString += "Steam" + pathSeparator()
				} else {
					rebuiltPathString += y + pathSeparator()
				}
			}
		} else {
			for x, y := range pathStrings {
				if x == 0 {
					continue
				}
				if strings.ToLower(y) == "steam" {
					rebuiltPathString += "Steam" + pathSeparator()
				} else {
					rebuiltPathString += y + pathSeparator()
				}
			}

		}
		return rebuiltPathString
	}
	return steamreader.steamPath
}

// GetLibraryVdfPath returns the path to the libraryfolders.vdf configuration file.
//
// This file is typically located in Steam's config directory and contains
// the list of library folders and their installed applications.
func (steamreader *SteamReader) GetLibraryVdfPath() string {
	return steamreader.libraryVdfPath
}

// FindAppIDPath returns the Steam library path containing the specified application.
//
// It searches through all configured library folders to find the application ID.
// Returns the library directory path where the application is installed.
// Returns an error if the application is not found in any library.
func (steamreader *SteamReader) FindAppIDPath(targetAppID string) (string, error) {
	libFoldersVal, exists := steamreader.libraryVdfMap.Get("libraryfolders")
	if !exists {
		return "", fmt.Errorf("libraryfolders key not found in the VDF data")
	}

	libFolders, ok := libFoldersVal.(*orderedmap.OrderedMap)
	if !ok {
		return "", fmt.Errorf("libraryfolders is not of the expected type")
	}

	for _, libKey := range libFolders.Keys() {
		libraryVal, exists := libFolders.Get(libKey)
		if !exists {
			continue
		}

		library := libraryVal.(*orderedmap.OrderedMap)

		pathVal, exists := library.Get("path")
		if !exists {
			return "", errors.New("libraryfolders.vdf: Path value does not exist...")
		}

		path := pathVal.(string)
		origPath := path
		path += pathSeparator() + "steamapps"
		directory, err := os.ReadDir(path)

		if err != nil {
			continue
		}

		for _, x := range directory {

			gameId, found := strings.CutPrefix(x.Name(), "appmanifest_")

			if !found {
				continue
			}

			gameId, found = strings.CutSuffix(gameId, ".acf")
			if !found {
				continue
			}

			if gameId == targetAppID {
				return origPath, nil
			}
		}

	}

	return "", fmt.Errorf("app with appid %s not found in any library", targetAppID)
}

// The code in this file was made by an LLM, use in production is highly discouraged as unexpected results may occur. The code in this file is not vetted for stability or edge cases.
